_Fill in each this file with your responses, placing each response after its
corresponding question._

---

**Question**

Pick three quotes from the readings about language design. Good candidates 
are:

   + Something you agreed with / resonates with your own experience
   + Something you disagree with
   + Something that is interesting, a new idea or perspective you'd like to remember
   + Something you didn't understand

For each quote, describe what it was about the quote that led you pick it.

**Response**
"We have to do this a lot when we write real computer programs: a thought that seems like a primitive in our minds turns out not to be a primitive in a programming language, and in each new program we must define it once more."

I chose this quote because I thought it was epecially true and interesting. It highlights the differences in various programming languages. Perhaps if you take some primitives to be more important than others then you will perfer languages with those defined primitives.

"In a race, a small language with warts will beat a well designed language because users will not wait for the right thing; they will use the language that is quick and cheap, and put up with the warts."

I chose this quote for two reasons. First, I think it's true but second it is a frustrating concept to me as I am somewhat of a perfectionist. I also do not think that choosing a poorly designed but easy to adopt language is better in the long run. In other words, I think it is the wrong choice. But people seem to choose it all the same.

"In Lisp, new words defined by the user look like primitives and, what is more, all primitives look like words defined by the user! In other words, if a user has good taste in defining new words, what comes out is a larger language that has no seams."

I chose this quote becuase I am a firm belever in the 'no seams' language quality. I beleive that there should be as few exceptions to the language rules as possible. And if there are exceptions, they should only seem like exceptions on the surface but when unpacked, they actually do follow the rules. I am also a beleiver in a small set of rules.

---

**Question**

How would you know a well-designed language? What are the symptoms? How would
you know a poorly designed language? What are the symptoms?

**Response**
I think one of the symptoms of a well designed language is that, as Guy Steele says, "new words defined by a library should look just like primitives of the language." In other words, the language should be seamless.

I think a symptom of a poorly designed language is that there are many exceptions to the language rules.


---

**Question**

How do the themes of _Growing a Language_ relate to the lab we did this week?

**Response**
In the lab we had everyone in the class working to improve the same 'language'. I think that that speaks to the bazaar way of building a language. 


---
 
**Question**


In what way is an API a language? 

**Response**
An API is a languge in that it has a predefined vocabulary and syntax. 


---

**Question**

What does the post on grayscale tell us about the process of API design?

**Response**
API design is like other types of design in that you need to get user feedback to find the best option and vocabulary.


---

**Question**

The comments on the Pavlus article seem to set up a conflict between
professional programmers and everyone else. What is the essence of this
conflict? Do you sympathize more with the substance of the article's arguments
or with the substance of the majority of the commenters' arguments? Do you
sympathize more with the tenor of the article or the tenor of the majority of
the commenters?

**Response**
The essence of this conflict I think is logical vs non-logical syntax. Personally, I find some solace in programming because it is completely logical. The English language is not completely logical but I still enjoy using it for exactly that reason. English is a language all the same as any programming language. We could imagine that eventually, English will be a programming language and we will be able to speak it to computers and have them understand it. But technology is not that far along yet so as of now we have to speak to computers in a more logical language. This is solely because computers think with electrical circuits and bit (purely logical) and humans think with brain cells (which leaves room for interpretation). Some people would prefer computers think more like humans, but other technical minded people may always prefer to think like computers. 

---

**Question**

The Pavlus article mentions the researchers' comments that people preferred
"natural-language replacements for some of the more abstruse syntax". In other 
words, people found it easier to work with code that looks more like a human language (e.g.,
English). Consider the following quote by William R. Cook, one of the creators
of AppleScript:


> The experiment in designing a language that resembled natural languages (English
> and Japanese) was not successful. It was assumed that scripts should be
> presented in “natural language” so that average people could read and write
> them. … In the end the syntactic variations and flexibility did more to confuse
> programmers than to help them out. It is not clear whether it is easier for
> novice users to work with a scripting language that resembles natural language,
> with all its special cases and idiosyncrasies. The main problem is that
> AppleScript only appears to be a natural language: in fact, it is an artificial
> language, like any other programming language. … even small changes to the
> script may introduce subtle syntactic errors that baffle users. It is easy to
> read AppleScript, but quite hard to write it.
[[Cook 2007, page 1-20]](https://dl.acm.org/citation.cfm?doid=1238844.1238845)

Are these two experiences of natural languages at odds with one another? Would
you choose to include natural language in the design of a DSL? If so, how might
you do so? If not, why not?

**Response**
I do not think they are at odds with eachother. Most people undeniably prefer to use natural language. However, the problem arises when they start to confuse a pseudo-natural language with actual natural language. Computers are not yet advnaced enough to actually interpret natural language so when you try to put natural language into a programming language, you are basically lying to the user. You are saying, I can understand natuaral language when really you cannot. This can cause the user errors. I most likely would not use natural language in the design of a DSL for exactly this reason. 


---

**Question**

Briefly describe how you split up the work for this assignment.

**Response**



---
